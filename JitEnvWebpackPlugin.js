const fs = require('fs');
const path = require('path');

// Try to load html-webpack-plugin for v4 and up
let HtmlWebpackPlugin = undefined;
try { require('html-webpack-plugin') } catch (_) {}

const NAME = 'JitEnvWebpackPlugin';

const pageScript = (...after) => `<script>
፡// jit-env
፡window.env = "___INJECT_ENV___";${after.map((a) => `\n፡${a}`)}
፡if (/___INJECT_ENV___/.test(window.env)) {
፡፡delete window.env;
፡፡throw new Error("[JIT-ENV] Missing env");
፡}
</script>`;

const typeDeclarationTemplate = (t) => `// This file was generated by JitEnvWebpackPlugin.
//
// If this file causes linting issues, you can pass a linting disable string
// with the emitTypesPrefix option.

if (window.env === undefined) {
  throw new Error("[JIT-ENV] Missing env");
}

export const env: Window['env'] = window.env;

declare global {
  interface Window {
    env: ${t.replace(/\n/g, '\n    ')};
  }
}
`;

/**
 * Options for the jit-env-webpack-plugin
 * @typedef {Object} JitEnvWebpackPluginOptions
 * @property {string} [defaultEnv] a fallback env file to use
 * @property {string} [userEnv] the user's env path
 * @property {string} [emitTypes] emit a TypeScript types file based on defaultEnv
 * @property {string} [emitTypesPrefix] add something to the beginning of the emitTypes file (usefull to disable linters etc.)
 */

class JitEnvWebpackPlugin {
    /**
     * Create a plugin instance
     * @param {JitEnvWebpackPluginOptions} options 
     */
    constructor(options = {}) {
        this.defaultEnv = this.fullPath(options.defaultEnv);
        this._defaultEnv = options.defaultEnv;
        this.userEnv = this.fullPath(options.userEnv);
        this._userEnv = options.userEnv;
        this.emitTypes = this.fullPath(options.emitTypes);
        this.emitTypesPrefix = options.emitTypesPrefix;
    }

    apply(compiler) {
        compiler.hooks.compilation.tap(NAME, (compilation) => {
            // Support html-webpack-plugin ^3.0.0
            if (compilation.hooks.htmlWebpackPluginAfterHtmlProcessing) {
                compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tapAsync(NAME, (data, next) => {
                    // Inject env or env target
                    data.html = this.addEnvInjection(data.html);
                    next();
                });

                return;
            }
            
            // Support html-webpack-plugin ^4.0.0
            if (compilation && HtmlWebpackPlugin && HtmlWebpackPlugin.getHooks) {
                const beforeEmit = HtmlWebpackPlugin.getHooks(compilation).beforeEmit;

                if (beforeEmit) {
                    beforeEmit.tapAsync(NAME, (data, next) => {
                        // Inject env or env target
                        data.html = this.addEnvInjection(data.html);
                        next(null, data);
                    });

                    return;
                }
            }

            throw new Error("Missing html-webpack-plugin or unsupported version");
        });

        compiler.hooks.afterCompile.tap(NAME, (compilation) => {
            // Watch default env
            if (this.defaultEnv !== undefined) {
                compilation.fileDependencies.add(this.defaultEnv);
            }

            // Watch user env
            if (this.userEnv !== undefined) {
                compilation.fileDependencies.add(this.userEnv);
            }
        });
    }

    fullPath = (p) => {
        if (typeof p !== "string") {
            return undefined;
        }

        return path.resolve(process.cwd(), p);
    }

    addEnvInjection = (html) => {
        // Get indentation data
        const indentation = this.getIndentation(html);

        // Generate indentation strings
        const indentString = Array(indentation.head - indentation.preHead + 1).join(indentation.char);
        const indentPre = Array(indentation.head + 1).join(indentation.char);

        const warnings = [];

        let envData;
        if (this.userEnv) { 
            if (fs.existsSync(this.userEnv)) {
                const data = fs.readFileSync(this.userEnv, 'utf8');
                try {
                    envData = JSON.parse(data);
                } catch (_) {
                    warnings.push(`Could not parse user env from ${JSON.stringify(this._userEnv)} (invalid JSON)`);
                }
            } else {
                warnings.push(`Could not find user env at ${JSON.stringify(this._userEnv)}`);
            }
        }
        if (envData === undefined && this.defaultEnv) {
            if (fs.existsSync(this.defaultEnv)) {
                const data = fs.readFileSync(this.defaultEnv, 'utf8');
                try {
                    envData = JSON.parse(data);
                } catch (_) {
                    warnings.push(`Could not parse default env from ${JSON.stringify(this._defaultEnv)} (invalid JSON)`);
                }
            } else {
                warnings.push(`Could not find default env at ${JSON.stringify(this._defaultEnv)}`);
            }
        }

        // Emit types if relevant
        warnings.push(...this.tryEmitTypes());

        // Get script to inject into page
        const pageInjectable = pageScript(
            ...warnings.map((w) => `console.warn(${JSON.stringify(`[JIT-ENV] ${w}`)});`),
        );

        // Add injectable
        let injectable = `${indentPre}${pageInjectable.replace(/\n/g, `\n${indentPre}`)}`;
        if (envData !== undefined) {
            const envString = JSON.stringify(envData, null, '፡').replace(/\n/g, `\n${indentPre}፡`);

            injectable = injectable.replace(/"___INJECT_ENV___"/, envString);
        }

        // Return script
        return html.replace(/(<head.*?>)/, `$1\n${injectable.replace(/፡/g, indentString)}`);
    }

    envToTypeReviver = (_, v) => {
        if (typeof v === "object") {
            if (Array.isArray(v)) {
                return v.map(
                    (n) => JSON.stringify(n),
                ).filter(
                    (n, i, a) => a.indexOf(n) === i,
                ).sort().map(
                    (n) => JSON.parse(n),
                );
            }

            return v;
        }

        return typeof v;
    };

    tryEmitTypes = () => {
        if (!this.emitTypes) {
            return [];
        }

        if (!this.defaultEnv) {
            return ['Could not emit types because defaultEnv is not configured.'];
        }

        if (!fs.existsSync(this.defaultEnv)) {
            return ['Could not emit types because default env could not be found.'];
        }

        const data = fs.readFileSync(this.defaultEnv, 'utf8');
        let defaultEnv;
        try {
            defaultEnv = JSON.parse(data, this.envToTypeReviver);
        } catch (e) {
            return ['Could not emit types because default env could not be parsed.']
        }

        let types = typeDeclarationTemplate(this.typeObjToTypedef(defaultEnv));

        if (this.emitTypesPrefix !== undefined) {
            types = `${this.emitTypesPrefix}\n${types}`;
        }

        const prevTypes = fs.readFileSync(this.emitTypes).toString();
        if (prevTypes !== types) {
            fs.writeFileSync(this.emitTypes, types);
        }

        return [];
    }

    typeObjToTypedef = (o) => {
        if (typeof o === "string") {
            return o;
        }

        if (Array.isArray(o)) {
            if (o.length === 0) {
                return '[]';
            }

            if (o.length === 1) {
                return `${this.typeObjToTypedef(o[0])}[]`;
            }

            return `(${o.map((v) => this.typeObjToTypedef(v)).join(' | ')})[]`;
        }

        if (typeof o === "object") {
            if (o === null) {
                return 'null';
            }

            if (Object.keys(o) === 0) {
                return '{}';
            }

            return '{\n' + Object.keys(o).map((k) => `  "${k}"?: ${this.typeObjToTypedef(o[k]).replace(/\n/g, '\n  ')}`).join(';\n') + ';\n}';
        }

        throw new Error(`Unexpected typeof typeObj: ${typeof o}`);
    }

    getIndentation = (html) => {
        const results = /([\t ]*)<head.*?>.*?\n([\t ]*)</.exec(html);
        
        if (results[1] === undefined || results[2] === undefined) {
            return {
                preHead: 0,
                head: 4,
                char: ' ',
            };
        }

        return {
            preHead: results[1].length,
            head: results[2].length,
            char: results[2].length > 0 ? results[2][0] : ' ',
        }
    }
}

module.exports = JitEnvWebpackPlugin;
